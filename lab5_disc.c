#include<stdio.h>
#include<conio.h>
#define INFINITY 9999
#define MAX 30

void dijkstra(int G[MAX][MAX],int n,int startnode);

int main()
{
    int n = 30, u = 0;

   int G[30][30] ={{0,4,0,0,0,0,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, //матриця суміжності
        /*2*/  {4,0,4,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
        /*3*/  {0,4,0,3,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
        /*4*/  {0,0,3,0,1,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
        /*5*/  {0,4,0,1,0,3,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
        /*6*/  {0,4,0,0,3,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
        /*7*/  {6,4,0,0,0,0,0,4,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
        /*8*/  {0,2,0,0,0,0,4,0,1,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
        /*9*/  {0,0,3,0,0,0,0,1,0,1,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
        /*10*/ {0,0,0,4,0,0,0,0,1,0,2,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
        /*11*/ {0,0,0,0,5,0,0,0,0,2,0,7,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0},
        /*12*/ {0,0,0,0,0,8,0,0,0,0,7,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0},
        /*13*/ {0,0,0,0,0,0,1,0,0,0,0,0,0,4,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0},
        /*14*/ {0,0,0,0,0,0,0,7,0,0,0,0,4,0,1,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0},
        /*15*/ {0,0,0,0,0,0,0,0,5,0,0,0,0,1,0,2,0,0,0,0,7,0,0,0,0,0,0,0,0,0},
        /*16*/ {0,0,0,0,0,0,0,0,0,7,0,0,0,0,2,0,7,0,0,0,0,1,0,0,0,0,0,0,0,0},
        /*17*/ {0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,7,0,7,0,0,0,0,2,0,0,0,0,0,0,0},
        /*18*/ {0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,7,0,0,0,0,0,0,8,0,0,0,0,0,0},
        /*19*/ {0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,8,0,0,0,0,5,0,0,0,0,0},
        /*20*/ {0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,8,0,3,0,0,0,0,2,0,0,0,0},
        /*21*/ {0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,3,0,8,0,0,0,0,3,0,0,0},
        /*22*/ {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,8,0,1,0,0,0,0,1,0,0},
        /*23*/ {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,1,0,5,0,0,0,0,3,0},
        /*24*/ {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,0,5,0,0,0,0,0,0,7},
        /*25*/ {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,0,0,0,0,0,1,0,0,0,0},
        /*26*/ {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,1,0,3,0,0,0},
        /*27*/ {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,3,0,3,0,0},
        /*28*/ {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,3,0,3,0},
        /*29*/ {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,3,0,6},
        /*30*/ {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,6,0}};
    dijkstra(G,n,u);

    return 0;
}

void dijkstra(int G[MAX][MAX],int n,int startnode)
{

    int cost[MAX][MAX],distance[MAX],pred[MAX];
    int visited[MAX],count,min_distance,nextnode,i,j;

    for(i=0;i<n;i++)
        for(j=0;j<n;j++)
            if(G[i][j]==0)
                cost[i][j]=INFINITY;  //створює матрицю ваг і якщо в матриці суміжності елемент
            else                      //дорівнює нулю то відстань до нього безкінечна і шлях до нього не існує
                cost[i][j]=G[i][j];   //в іншому випадку передає значення  матриці суміжності до матриці ваг


    for(i=0;i<n;i++)
    {
        distance[i]=cost[startnode][i];  // створює масив ваг ребер і передає в нього значення з
        pred[i]=startnode;               // матриці ваг
        visited[i]=0;                    // заповнює пройдені вершини нулями
    }
    distance[startnode]=0;   // заповнює вагу початкової вершини нулем
    visited[startnode]=1;    // записує що початкову вершину пройдено
    count=1;                 // індикатор пройдених точок

    while(count<n-1)
    {
        min_distance=INFINITY;

        for(i=0;i<n;i++)
            if(distance[i]<min_distance&&!visited[i]) //знаходження найменшого шляху і перевірка чи вершина вже пройдена
            {                                         // щоб не утворити цикл
                min_distance=distance[i];
                nextnode=i;                           // зберігає місце знаходження найменшої ваги
            }


            visited[nextnode]=1; //записує що ребро з найменшою вагою пройдено

            for(i=0;i<n;i++)            // додаткова перевірка не пройдених ребер і перевірка чи дійсно в минулій перевірці
                if(!visited[i])         // було знайдено найменше ребро
                    if(min_distance+cost[nextnode][i]<distance[i]) //записує мінімальний шлях від початкової точки до заданої
                    {
                        distance[i]=min_distance+cost[nextnode][i];
                        pred[i]=nextnode;                          //зберігає в масив вершину мінімальний шлях до якої було знайдено
                    }
        count++;
    }

//вивід інформації про мінімальні шляхи до вершин і як саме пройдено шлях
    for(i=0;i<n;i++)
        if(i!=startnode) // пропуск початкової вершини
        {
            printf("\nDistance of node[%d] = %d",i+1,distance[i]);
            printf("\nPath = [%d]",i+1);

            j=i;
            do
            {
                j=pred[j];
                printf("<-[%d]",j+1);
            }while(j!=startnode);
    }
}
